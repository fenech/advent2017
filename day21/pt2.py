s = """../.. => ..#/#../.#.
#./.. => #../#../...
##/.. => ###/#.#/#..
.#/#. => ###/##./.#.
##/#. => .../.#./..#
##/## => ##./#.#/###
.../.../... => ##../.#../#.#./....
#../.../... => ..../##.#/...#/##.#
.#./.../... => ###./####/#.../#..#
##./.../... => ###./.##./...#/..##
#.#/.../... => .###/.##./#.../#.##
###/.../... => ##.#/#..#/#.#./#.##
.#./#../... => #.#./.###/#.../#.##
##./#../... => #.../####/#.##/....
..#/#../... => #.##/..#./...#/...#
#.#/#../... => #.##/####/.#.#/#.#.
.##/#../... => #.../##../##.#/.##.
###/#../... => ..../#.#./.###/#...
.../.#./... => .#.#/#..#/##../#.##
#../.#./... => ###./.###/.#.#/..#.
.#./.#./... => ..##/.##./..##/.#.#
##./.#./... => ..#./##../###./...#
#.#/.#./... => ..##/.##./.###/###.
###/.#./... => ..#./.###/###./#.##
.#./##./... => ###./..../.#../#...
##./##./... => .#.#/##../##.#/...#
..#/##./... => ##.#/.##./.###/..##
#.#/##./... => .###/..#./#.##/####
.##/##./... => ##.#/..#./..##/###.
###/##./... => ..../.#.#/.#../#...
.../#.#/... => ###./.#.#/.#../#.##
#../#.#/... => ####/#..#/..../....
.#./#.#/... => #.../..##/#.##/#.#.
##./#.#/... => #.#./###./##../#.#.
#.#/#.#/... => ...#/.##./.##./.#..
###/#.#/... => ..../.##./####/#.#.
.../###/... => .###/.#../.###/#.##
#../###/... => ..##/..##/.##./##..
.#./###/... => .#.#/..#./..##/##.#
##./###/... => ...#/#.##/#.#./##.#
#.#/###/... => #.##/.##./...#/###.
###/###/... => ##../...#/..##/####
..#/.../#.. => #.##/#.../.#../#.#.
#.#/.../#.. => .##./.##./.#.#/.##.
.##/.../#.. => .#.#/#.##/...#/##.#
###/.../#.. => ##../..#./...#/##..
.##/#../#.. => ##../..##/#..#/#..#
###/#../#.. => ##../..#./#.#./....
..#/.#./#.. => .##./##.#/##../####
#.#/.#./#.. => ####/...#/.#.#/..#.
.##/.#./#.. => .#.#/..#./##.#/.#..
###/.#./#.. => #.../#.##/..../##.#
.##/##./#.. => #.#./#.#./#.##/#.#.
###/##./#.. => ...#/###./.##./.#.#
#../..#/#.. => ####/####/..../.##.
.#./..#/#.. => #.##/...#/..#./####
##./..#/#.. => ..#./#.../..##/####
#.#/..#/#.. => #.../#.##/#.##/..##
.##/..#/#.. => ####/..../##../####
###/..#/#.. => ..../##.#/.##./####
#../#.#/#.. => ...#/..##/###./#..#
.#./#.#/#.. => #..#/..#./.###/##.#
##./#.#/#.. => ###./####/#.##/..#.
..#/#.#/#.. => ##../##.#/..##/.##.
#.#/#.#/#.. => .#.#/.##./#.../##.#
.##/#.#/#.. => .#.#/#..#/.##./..#.
###/#.#/#.. => ...#/.#../.##./##.#
#../.##/#.. => ###./##../#.#./####
.#./.##/#.. => .#../##../#.#./.#.#
##./.##/#.. => ##.#/.#../.#.#/####
#.#/.##/#.. => ####/.#.#/..../....
.##/.##/#.. => ####/##../#..#/####
###/.##/#.. => .###/##.#/.#../#.##
#../###/#.. => #..#/###./####/.#.#
.#./###/#.. => ..##/##../##.#/.#.#
##./###/#.. => #..#/.#../####/...#
..#/###/#.. => ##../##.#/...#/#..#
#.#/###/#.. => ..#./.##./#..#/....
.##/###/#.. => #..#/#.../..../.#..
###/###/#.. => ..#./#.##/.##./#...
.#./#.#/.#. => .#.#/.##./##.#/.##.
##./#.#/.#. => #..#/.###/.#.#/.##.
#.#/#.#/.#. => #.../##../#.../.###
###/#.#/.#. => ###./.###/###./....
.#./###/.#. => .#../####/...#/##..
##./###/.#. => ####/###./..../....
#.#/###/.#. => ...#/.###/..../####
###/###/.#. => ..../#.../..#./.###
#.#/..#/##. => #.#./#.../####/#.##
###/..#/##. => .#.#/#..#/.###/#...
.##/#.#/##. => ..##/..#./..../##..
###/#.#/##. => #.#./##.#/####/#..#
#.#/.##/##. => ..../.#../#.#./##.#
###/.##/##. => ..../..../.#../##.#
.##/###/##. => #.#./.###/#.#./#.##
###/###/##. => ##.#/##.#/.###/..#.
#.#/.../#.# => #..#/.#../#.../...#
###/.../#.# => ##../.#../##.#/..#.
###/#../#.# => ..##/#.#./####/.#..
#.#/.#./#.# => ...#/...#/#..#/#.#.
###/.#./#.# => ..../####/.##./.#.#
###/##./#.# => #..#/.#.#/..##/####
#.#/#.#/#.# => #.#./..#./...#/.#..
###/#.#/#.# => ...#/##.#/.###/.#..
#.#/###/#.# => .#.#/###./.#../.##.
###/###/#.# => ...#/.###/.#.#/###.
###/#.#/### => #.##/.#.#/...#/.#..
###/###/### => ..##/.#../#.#./.#..
"""

from re import match
from math import sqrt

pattern = ".#./..#/###"

def flip_horizontal(rule):
    return "/".join(map("".join, map(reversed, rule.split("/"))))

def rotate_clockwise(rule):
    rows = rule.split("/")
    return "/".join(["".join([r[i] for r in reversed(rows)]) for i, row in enumerate(rows)])

def generate_rules(rule, rotations=4):
    if rotations == 0:
        raise StopIteration

    yield rule
    yield flip_horizontal(rule)
    for rule in generate_rules(rotate_clockwise(rule), rotations - 1):
        yield rule

def add_rules(m, rule_book):
    rule_input = m.group(1)
    rule_output = m.group(2)
    for rule in generate_rules(rule_input):
        rule_book[rule] = rule_output

rules_2x2 = {}
rules_3x3 = {}

class ParseError(Exception):
    pass

for line in s.splitlines():
    m = match(r"(../..) => (.../.../...)", line)
    if m is not None:
        add_rules(m, rules_2x2)
        continue

    m = match(r"(.../.../...) => (..../..../..../....)", line)
    if m is not None:
        add_rules(m, rules_3x3)
        continue

    raise ParseError

def split_grid(pattern):
    size = pattern.index("/")
    subgrid_size = 2 if size % 2 == 0 else 3

    num_rows = num_cols = size // subgrid_size

    rows = pattern.split("/")

    subgrids = [["" for i in range(num_cols)] for j in range(num_rows)]

    for j in range(size):
        for i in range(size):
            subgrids[j // subgrid_size][i // subgrid_size] += rows[j][i]

    for row in subgrids:
        for subgrid in row:
            yield "/".join(subgrid[i:i+subgrid_size] for i in range(0, subgrid_size * subgrid_size, subgrid_size))

def join_grid(subgrids):
    subgrids = [s.split("/") for s in subgrids]

    subgrid_size = len(subgrids[0][0])
    size = int(subgrid_size * sqrt(len(subgrids)))

    num_cols = size // subgrid_size

    grid = ["" for i in range(size)]

    for subgrid_index, subgrid in enumerate(subgrids):
        for row_index, row in enumerate(subgrid):
            grid[row_index + subgrid_index // num_cols * subgrid_size] += row

    return "/".join(grid)

def enhance(pattern):
    try:
        return rules_2x2[pattern]
    except KeyError:
        return rules_3x3[pattern]

for i in range(18):
    pattern = join_grid((enhance(subgrid) for subgrid in split_grid(pattern)))
    print("\n".join(pattern.split("/")))

print(sum(c == "#" for c in pattern))
